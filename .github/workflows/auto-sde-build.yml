name: Auto SDE Build and Release

on:
  workflow_dispatch:
    inputs:
      build_patch:
        description: '构建补丁包（即使已存在相同build_number的release也重新构建）'
        required: false
        default: false
        type: boolean
      debug:
        description: '调试模式（只执行构建，不创建release、不commit、不push）'
        required: false
        default: false
        type: boolean
  schedule:
    # 每天固定时间（UTC时间）
    - cron: '20 11 * * *'   # 北京时间 19:20
    - cron: '40 11 * * *'   # 北京时间 19:40
    - cron: '0 13 * * *'   # 北京时间 21:00 

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

jobs:
  get-build-info:
    name: 获取SDE版本信息
    runs-on: ubuntu-latest
    
    outputs:
      build-number: ${{ steps.get-build-info.outputs.build-number }}
      release-date: ${{ steps.get-build-info.outputs.release-date }}
      build-key: ${{ steps.get-build-info.outputs.build-key }}
      new-build: ${{ steps.get-build-info.outputs.new-build }}
      patch-version: ${{ steps.get-build-info.outputs.patch-version }}
      final-build-number: ${{ steps.get-build-info.outputs.final-build-number }}
      debug-mode: ${{ steps.get-build-info.outputs.debug-mode }}
    
    steps:
    - name: 获取SDE版本信息并检查重复
      id: get-build-info
      run: |
        echo "[+] 获取最新SDE版本信息..."
        
        # 获取最新SDE信息
        SDE_INFO=$(curl -s "https://developers.eveonline.com/static-data/tranquility/latest.jsonl" | jq -r '.')
        
        BUILD_NUMBER=$(echo "$SDE_INFO" | jq -r '.build_number')
        RELEASE_DATE=$(echo "$SDE_INFO" | jq -r '.releaseDate')
        BUILD_KEY=$(echo "$SDE_INFO" | jq -r '._key')
        
        echo "Build number: ${BUILD_NUMBER}"
        echo "Release date: ${RELEASE_DATE}"
        echo "Build key: ${BUILD_KEY}"
        
        # 检查是否为调试模式
        DEBUG_MODE="${{ github.event.inputs.debug }}"
        echo "Debug mode: ${DEBUG_MODE}"
        
        # 检查是否为补丁包构建
        BUILD_PATCH="${{ github.event.inputs.build_patch }}"
        echo "Build patch mode: ${BUILD_PATCH}"
        
        # 如果是调试模式，跳过release检查，直接设置new-build=true
        if [ "$DEBUG_MODE" = "true" ]; then
          echo "[+] 调试模式：跳过Release检查，只执行构建"
          NEW_BUILD="true"
          FINAL_BUILD_NUMBER="${BUILD_NUMBER}"
          PATCH_VERSION=0
          echo "patch-version=${PATCH_VERSION}" >> $GITHUB_OUTPUT
          echo "final-build-number=${FINAL_BUILD_NUMBER}" >> $GITHUB_OUTPUT
          echo "build-number=${BUILD_NUMBER}" >> $GITHUB_OUTPUT
          echo "release-date=${RELEASE_DATE}" >> $GITHUB_OUTPUT
          echo "build-key=${BUILD_KEY}" >> $GITHUB_OUTPUT
          echo "new-build=${NEW_BUILD}" >> $GITHUB_OUTPUT
          echo "debug-mode=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "debug-mode=false" >> $GITHUB_OUTPUT
        
        # 首先检查原始build_number的release是否已存在
        TAG_NAME="sde-build-${BUILD_NUMBER}"
        echo "[+] 检查Release是否已存在: ${TAG_NAME}"
        
        RELEASE_EXISTS=$(curl -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -s \
          "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG_NAME}" | jq -r '.id')
        
        if [ "$BUILD_PATCH" = "true" ]; then
          echo "[+] 补丁包模式：强制重新构建"
          
          if [ "$RELEASE_EXISTS" != "null" ] && [ -n "$RELEASE_EXISTS" ]; then
            echo "[+] 原始版本已存在，查找下一个可用的补丁版本号"
            
            # 查找已存在的补丁版本
            PATCH_VERSION=1
            FINAL_BUILD_NUMBER="${BUILD_NUMBER}.01"
            
            # 检查补丁版本直到找到可用的版本号（最多99次）
            while [ $PATCH_VERSION -le 99 ]; do
              PATCH_STR=$(printf "%02d" $PATCH_VERSION)
              TAG_NAME="sde-build-${BUILD_NUMBER}.${PATCH_STR}"
              
              echo "[+] 检查补丁版本: ${TAG_NAME}"
              RELEASE_EXISTS=$(curl -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -s \
                "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG_NAME}" | jq -r '.id')
              
              if [ "$RELEASE_EXISTS" = "null" ] || [ -z "$RELEASE_EXISTS" ]; then
                echo "[+] 找到可用的补丁版本: ${TAG_NAME}"
                FINAL_BUILD_NUMBER="${BUILD_NUMBER}.${PATCH_STR}"
                NEW_BUILD="true"
                break
              else
                echo "补丁版本 ${TAG_NAME} 已存在，尝试下一个"
                PATCH_VERSION=$((PATCH_VERSION + 1))
              fi
            done
            
            if [ $PATCH_VERSION -gt 99 ]; then
              echo "[x] 错误：已达到补丁版本上限（99），无法创建新的补丁包"
              exit 1
            fi
          else
            echo "[+] 原始版本不存在，直接使用原始build_number"
            FINAL_BUILD_NUMBER="${BUILD_NUMBER}"
            PATCH_VERSION=0
            NEW_BUILD="true"
          fi
          
          echo "patch-version=${PATCH_VERSION}" >> $GITHUB_OUTPUT
          echo "final-build-number=${FINAL_BUILD_NUMBER}" >> $GITHUB_OUTPUT
        else
          # 正常模式：检查Release是否已存在
          if [ "$RELEASE_EXISTS" != "null" ] && [ -n "$RELEASE_EXISTS" ]; then
            echo "Release ${TAG_NAME} 已存在，跳过构建"
            NEW_BUILD="false"
          else
            echo "新版本 ${TAG_NAME} 需要构建"
            NEW_BUILD="true"
          fi
          
          echo "patch-version=0" >> $GITHUB_OUTPUT
          echo "final-build-number=${BUILD_NUMBER}" >> $GITHUB_OUTPUT
        fi
        
        echo "build-number=${BUILD_NUMBER}" >> $GITHUB_OUTPUT
        echo "release-date=${RELEASE_DATE}" >> $GITHUB_OUTPUT
        echo "build-key=${BUILD_KEY}" >> $GITHUB_OUTPUT
        echo "new-build=${NEW_BUILD}" >> $GITHUB_OUTPUT

  build-sde:
    name: 构建SDE数据库
    runs-on: ubuntu-latest
    
    needs: [get-build-info]
    if: needs.get-build-info.outputs.new-build == 'true'
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
    
    - name: 设置Python环境
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: 安装依赖
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: 执行SDE构建
      id: build-sde
      run: |
        echo "[+] 执行SDE构建"
        echo "[+] Build Number: ${{ needs.get-build-info.outputs.build-number }}"
        echo "[+] Final Build Number: ${{ needs.get-build-info.outputs.final-build-number }}"
        echo "[+] Patch Version: ${{ needs.get-build-info.outputs.patch-version }}"
        
        # 设置环境变量，让main.py知道最终的build number
        export FINAL_BUILD_NUMBER="${{ needs.get-build-info.outputs.final-build-number }}"
        export PATCH_VERSION="${{ needs.get-build-info.outputs.patch-version }}"
        
        python -u main.py
        
        # 检查物品详情目录是否生成
        echo "[+] 检查物品详情目录..."
        echo "[+] 当前目录内容:"
        ls -la
        
        if [ -d "item_detail_en" ]; then
          echo "[+] 英文版物品详情目录存在"
          echo "[+] 英文版目录内容:"
          ls -la item_detail_en/ | head -10
        else
          echo "[!] 英文版物品详情目录不存在"
        fi
        
        if [ -d "item_detail_zh" ]; then
          echo "[+] 中文版物品详情目录存在"
          echo "[+] 中文版目录内容:"
          ls -la item_detail_zh/ | head -10
        else
          echo "[!] 中文版物品详情目录不存在"
        fi
        
        if [ -d "item_detail_en" ] && [ -d "item_detail_zh" ]; then
          echo "item-detail-extracted=true" >> $GITHUB_OUTPUT
          echo "[+] 物品详情目录已生成"
          echo "[+] 设置输出: item-detail-extracted=true"
        else
          echo "item-detail-extracted=false" >> $GITHUB_OUTPUT
          echo "[!] 物品详情目录未生成"
          echo "[+] 设置输出: item-detail-extracted=false"
        fi
    
    - name: 上传构建产物
      id: upload-artifact
      uses: actions/upload-artifact@v4
      with:
        name: sde-output-${{ needs.get-build-info.outputs.final-build-number }}
        path: |
          output_sde/
          output_icons/
          item_detail_en/
          item_detail_zh/
          release_compare_${{ needs.get-build-info.outputs.final-build-number }}.md
        retention-days: 30
    
    outputs:
      item-detail-extracted: ${{ steps.build-sde.outputs.item-detail-extracted }}

  create-release:
    name: 创建Release
    runs-on: ubuntu-latest
    
    needs: [get-build-info, build-sde]
    if: needs.get-build-info.outputs.new-build == 'true' && needs.get-build-info.outputs.debug-mode != 'true'
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
    
    - name: 下载构建产物
      uses: actions/download-artifact@v4
      with:
        name: sde-output-${{ needs.get-build-info.outputs.final-build-number }}
        path: ./
    
    - name: 创建压缩包
      run: |
        FINAL_BUILD_NUMBER="${{ needs.get-build-info.outputs.final-build-number }}"
        
        # 创建图标压缩包（从output_icons/icons.zip复制）
        if [ -f "output_icons/icons.zip" ]; then
          cp "output_icons/icons.zip" "icons.zip"
          echo "[+] 图标压缩包创建完成: icons.zip"
        else
          echo "[x] 图标压缩包不存在: output_icons/icons.zip"
          exit 1
        fi
        
        # 创建SDE数据压缩包（直接压缩output_sde目录为ZIP格式）
        cd output_sde
        zip -r "../sde.zip" .
        cd ..
        
        echo "[+] SDE数据压缩包创建完成: sde.zip"
        ls -la icons.zip sde.zip
    
    - name: 验证压缩包
      id: verify-packages
      run: |
        echo "[+] 验证压缩包..."
        
        # 验证图标压缩包
        if [ ! -f "icons.zip" ]; then
          echo "[x] 图标压缩包不存在: icons.zip"
          exit 1
        fi
        
        ICONS_SIZE=$(stat -c%s "icons.zip")
        ICONS_SIZE_MB=$((ICONS_SIZE / 1024 / 1024))
        echo "[+] 图标压缩包大小: ${ICONS_SIZE_MB} MB (${ICONS_SIZE} bytes)"
        
        # 验证SDE数据压缩包
        if [ ! -f "sde.zip" ]; then
          echo "[x] SDE数据压缩包不存在: sde.zip"
          exit 1
        fi
        
        SDE_SIZE=$(stat -c%s "sde.zip")
        SDE_SIZE_MB=$((SDE_SIZE / 1024 / 1024))
        echo "[+] SDE数据压缩包大小: ${SDE_SIZE_MB} MB (${SDE_SIZE} bytes)"
        
        # 检查压缩包大小是否合理
        if [ $ICONS_SIZE_MB -lt 1 ]; then
          echo "[x] 图标压缩包大小异常，可能构建失败"
          exit 1
        fi
        
        if [ $SDE_SIZE_MB -lt 5 ]; then
          echo "[x] SDE数据压缩包大小异常，可能构建失败"
          exit 1
        fi
        
        # 计算压缩包哈希值
        ICONS_SHA256=$(sha256sum "icons.zip" | cut -d' ' -f1)
        SDE_SHA256=$(sha256sum "sde.zip" | cut -d' ' -f1)
        echo "[+] 图标压缩包SHA256: $ICONS_SHA256"
        echo "[+] SDE数据压缩包SHA256: $SDE_SHA256"
        
        # 将SHA256值输出到环境变量，供后续步骤使用
        echo "icons-sha256=${ICONS_SHA256}" >> $GITHUB_OUTPUT
        echo "sde-sha256=${SDE_SHA256}" >> $GITHUB_OUTPUT
        
        # 验证压缩包完整性
        if unzip -t "icons.zip" > /dev/null 2>&1; then
          echo "[+] 图标压缩包完整性验证通过"
        else
          echo "[x] 图标压缩包损坏或格式错误"
          exit 1
        fi
        
        if unzip -t "sde.zip" > /dev/null 2>&1; then
          echo "[+] SDE数据压缩包完整性验证通过"
        else
          echo "[x] SDE数据压缩包损坏或格式错误"
          exit 1
        fi
        
        # 显示压缩包内容概览
        echo "[+] 图标压缩包内容概览:"
        unzip -l "icons.zip" | head -10
        
        echo "[+] SDE数据压缩包内容概览:"
        unzip -l "sde.zip" | head -10
        SDE_TOTAL_FILES=$(unzip -l "sde.zip" | tail -1 | awk '{print $2}')
        echo "[+] SDE数据压缩包包含 $SDE_TOTAL_FILES 个文件"
        
        # 显示sde.zip的目录结构（tree视图）
        echo "[+] SDE数据压缩包目录结构:"
        echo "sde.zip"
        unzip -l "sde.zip" | grep -E '\.(sqlite|json|log)$' | awk '{print "├── " $4}' | sort | head -20
        if [ $(unzip -l "sde.zip" | grep -E '\.(sqlite|json|log)$' | wc -l) -gt 20 ]; then
          echo "└── ... (还有更多文件)"
        fi
        
        echo "[+] 压缩包验证完成"
    
    - name: 生成完整的metadata.json
      id: generate-metadata
      run: |
        echo "[+] 生成完整的metadata.json..."
        
        # 验证必需的参数
        ICONS_SHA256="${{ steps.verify-packages.outputs.icons-sha256 }}"
        SDE_SHA256="${{ steps.verify-packages.outputs.sde-sha256 }}"
        BUILD_NUMBER="${{ needs.get-build-info.outputs.build-number }}"
        PATCH_VERSION="${{ needs.get-build-info.outputs.patch-version }}"
        RELEASE_DATE="${{ needs.get-build-info.outputs.release-date }}"
        
        # 严格验证所有必需参数
        if [ -z "$ICONS_SHA256" ] || [ "$ICONS_SHA256" = "null" ]; then
          echo "[x] 错误：icons.zip SHA256未计算或为空"
          exit 1
        fi
        
        if [ -z "$SDE_SHA256" ] || [ "$SDE_SHA256" = "null" ]; then
          echo "[x] 错误：sde.zip SHA256未计算或为空"
          exit 1
        fi
        
        if [ -z "$BUILD_NUMBER" ] || [ "$BUILD_NUMBER" = "null" ]; then
          echo "[x] 错误：build_number未设置"
          exit 1
        fi
        
        if [ -z "$RELEASE_DATE" ] || [ "$RELEASE_DATE" = "null" ]; then
          echo "[x] 错误：release_date未设置"
          exit 1
        fi
        
        echo "[+] icons.zip SHA256: $ICONS_SHA256"
        echo "[+] sde.zip SHA256: $SDE_SHA256"
        echo "[+] Build Number: $BUILD_NUMBER"
        echo "[+] Patch Version: $PATCH_VERSION"
        echo "[+] Release Date: $RELEASE_DATE"
        
        # 尝试从最新Release获取metadata.json以计算icon_version
        echo "[+] 获取远程metadata.json以计算icon_version..."
        
        METADATA_URL=""
        
        # 策略1: 尝试使用/releases/latest API
        echo "[+] 尝试使用/releases/latest API..."
        LATEST_RELEASE=$(curl -s "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/latest" 2>/dev/null)
        
        # 检查/releases/latest是否成功（非404）
        if [ -n "$LATEST_RELEASE" ] && [ "$LATEST_RELEASE" != "null" ] && echo "$LATEST_RELEASE" | jq -e '.assets' > /dev/null 2>&1; then
          echo "[+] 成功获取/releases/latest API响应"
          METADATA_URL=$(echo "$LATEST_RELEASE" | jq -r '.assets[] | select(.name == "metadata.json") | .browser_download_url' 2>/dev/null || echo "")
          
          # 如果/releases/latest成功但没有metadata.json，这是异常情况，应该报错
          if [ -z "$METADATA_URL" ] || [ "$METADATA_URL" = "null" ] || [ "$METADATA_URL" = "" ]; then
            echo "[x] 错误：/releases/latest API成功但未找到metadata.json"
            echo "[x] 这是一个致命错误，最新release必须包含metadata.json"
            exit 1
          fi
          
          echo "[+] 从/releases/latest找到metadata.json: $METADATA_URL"
        else
          # /releases/latest失败（可能是404），尝试策略2
          echo "[!] /releases/latest API未找到或返回404，尝试回退策略..."
          
          # 策略2: 回退到/releases API，找到id最大的release
          echo "[+] 请求/releases API获取所有releases..."
          ALL_RELEASES=$(curl -s "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases" 2>/dev/null)
          
          # 严格验证/releases API响应
          if [ -z "$ALL_RELEASES" ] || [ "$ALL_RELEASES" = "null" ]; then
            echo "[x] 错误：/releases API请求失败或返回null"
            exit 1
          fi
          
          # 验证是否为有效数组
          if ! echo "$ALL_RELEASES" | jq -e 'type == "array"' > /dev/null 2>&1; then
            echo "[x] 错误：/releases API返回的不是有效数组"
            exit 1
          fi
          
          # 检查数组是否为空（没有release）
          RELEASE_COUNT=$(echo "$ALL_RELEASES" | jq 'length' 2>/dev/null || echo "0")
          if [ "$RELEASE_COUNT" = "0" ]; then
            echo "[+] /releases API返回空数组，说明没有任何release（首次创建）"
            echo "[+] 设置初始图标版本号: 1"
            METADATA_URL=""  # 确保METADATA_URL为空，以便后续逻辑设置版本为1
          else
            # 有release，找到id最大的release（排除draft和prerelease）
            echo "[+] 找到 $RELEASE_COUNT 个release，查找id最大的release..."
            LATEST_RELEASE=$(echo "$ALL_RELEASES" | jq '[.[] | select(.draft == false and .prerelease == false)] | sort_by(.id | tonumber) | reverse | .[0]' 2>/dev/null)
            
            # 验证是否找到有效的release
            if [ -z "$LATEST_RELEASE" ] || [ "$LATEST_RELEASE" = "null" ]; then
              echo "[x] 错误：未找到有效的release（排除draft和prerelease后为空）"
              exit 1
            fi
            
            echo "[+] 找到id最大的release"
            METADATA_URL=$(echo "$LATEST_RELEASE" | jq -r '.assets[]? | select(.name == "metadata.json") | .browser_download_url' 2>/dev/null || echo "")
            
            # 如果找到release但没有metadata.json，这是异常情况，应该报错
            if [ -z "$METADATA_URL" ] || [ "$METADATA_URL" = "null" ] || [ "$METADATA_URL" = "" ]; then
              echo "[x] 错误：id最大的release中没有metadata.json"
              echo "[x] 这是一个致命错误，release必须包含metadata.json"
              exit 1
            fi
            
            echo "[+] 从/releases找到metadata.json: $METADATA_URL"
          fi
        fi
        
        # 计算icon_version
        if [ -n "$METADATA_URL" ] && [ "$METADATA_URL" != "null" ] && [ "$METADATA_URL" != "" ]; then
          echo "[+] 找到远程metadata.json: $METADATA_URL"
          
          # 下载并解析旧的metadata（-L跟随重定向）
          OLD_METADATA=$(curl -sL "$METADATA_URL" 2>/dev/null)
          
          # 检查下载是否成功
          if [ -z "$OLD_METADATA" ] || [ "$OLD_METADATA" = "{}" ]; then
            echo "[x] 错误：找到了metadata.json但下载失败或为空"
            echo "[x] 这是一个致命错误，因为旧版本存在但无法访问"
            exit 1
          fi
          
          echo "[+] 远程metadata.json下载成功"
          
          # 解析字段
          OLD_ICONS_SHA=$(echo "$OLD_METADATA" | jq -r '.icon_sha256 // ""')
          OLD_ICON_VERSION=$(echo "$OLD_METADATA" | jq -r '.icon_version // ""')
          
          # 验证解析结果（如果找到了metadata，这些字段必须存在）
          if [ -z "$OLD_ICONS_SHA" ] || [ "$OLD_ICONS_SHA" = "null" ]; then
            echo "[x] 错误：找到了metadata.json但无法解析icon_sha256字段"
            echo "[x] 这是一个致命错误，metadata.json可能已损坏"
            exit 1
          fi
          
          if [ -z "$OLD_ICON_VERSION" ] || [ "$OLD_ICON_VERSION" = "null" ]; then
            echo "[x] 错误：找到了metadata.json但无法解析icon_version字段"
            echo "[x] 这是一个致命错误，metadata.json可能已损坏"
            exit 1
          fi
          
          echo "[+] 远程icons.zip SHA256: $OLD_ICONS_SHA"
          echo "[+] 旧版icon_version: $OLD_ICON_VERSION"
          
          # 比较SHA256
          if [ "$ICONS_SHA256" != "$OLD_ICONS_SHA" ]; then
            NEW_ICON_VERSION=$((OLD_ICON_VERSION + 1))
            echo "[+] SHA256不同，图标包已更新，新版本号: $NEW_ICON_VERSION"
          else
            NEW_ICON_VERSION=$OLD_ICON_VERSION
            echo "[+] SHA256相同，图标包未更新，版本号保持: $NEW_ICON_VERSION"
          fi
        else
          # 首次运行，没有旧版本metadata.json
          echo "[!] 未找到远程metadata.json（首次运行）"
          echo "[+] 设置初始图标版本号: 1"
          NEW_ICON_VERSION=1
        fi
        
        # 生成完整的metadata.json
        echo "[+] 创建完整的metadata.json..."
        jq -n \
          --argjson icon_version "$NEW_ICON_VERSION" \
          --arg icon_sha256 "$ICONS_SHA256" \
          --arg sde_sha256 "$SDE_SHA256" \
          --argjson build_number "$BUILD_NUMBER" \
          --argjson patch_number "$PATCH_VERSION" \
          --arg release_date "$RELEASE_DATE" \
          '{
            icon_version: $icon_version,
            icon_sha256: $icon_sha256,
            sde_sha256: $sde_sha256,
            build_number: $build_number,
            patch_number: $patch_number,
            release_date: $release_date
          }' > metadata.json
        
        # 严格验证metadata.json是否生成
        if [ ! -f "metadata.json" ]; then
          echo "[x] 错误：metadata.json文件未生成"
          exit 1
        fi
        
        # 验证metadata.json内容
        echo "[+] 验证metadata.json内容..."
        VERIFY_ICON_VERSION=$(cat metadata.json | jq -r '.icon_version // ""')
        VERIFY_ICON_SHA=$(cat metadata.json | jq -r '.icon_sha256 // ""')
        VERIFY_SDE_SHA=$(cat metadata.json | jq -r '.sde_sha256 // ""')
        VERIFY_BUILD=$(cat metadata.json | jq -r '.build_number // ""')
        VERIFY_DATE=$(cat metadata.json | jq -r '.release_date // ""')
        
        # 验证所有必需字段
        if [ -z "$VERIFY_ICON_VERSION" ] || [ "$VERIFY_ICON_VERSION" = "null" ]; then
          echo "[x] 错误：metadata.json中icon_version字段缺失或为空"
          exit 1
        fi
        
        if [ -z "$VERIFY_ICON_SHA" ] || [ "$VERIFY_ICON_SHA" = "null" ]; then
          echo "[x] 错误：metadata.json中icon_sha256字段缺失或为空"
          exit 1
        fi
        
        if [ -z "$VERIFY_SDE_SHA" ] || [ "$VERIFY_SDE_SHA" = "null" ]; then
          echo "[x] 错误：metadata.json中sde_sha256字段缺失或为空"
          exit 1
        fi
        
        if [ -z "$VERIFY_BUILD" ] || [ "$VERIFY_BUILD" = "null" ]; then
          echo "[x] 错误：metadata.json中build_number字段缺失或为空"
          exit 1
        fi
        
        if [ -z "$VERIFY_DATE" ] || [ "$VERIFY_DATE" = "null" ]; then
          echo "[x] 错误：metadata.json中release_date字段缺失或为空"
          exit 1
        fi
        
        echo "[+] metadata.json所有字段验证通过"
        echo "[+] 完整metadata.json内容:"
        cat metadata.json
        
        # 输出icon_version供后续使用
        echo "icon-version=${NEW_ICON_VERSION}" >> $GITHUB_OUTPUT
    
    - name: 生成时间戳用于文件名
      id: timestamp
      run: |
        TIMESTAMP=$(date -u +"%Y%m%d_%H%M%S")
        echo "value=${TIMESTAMP}" >> $GITHUB_OUTPUT
        echo "[+] 生成时间戳: ${TIMESTAMP}"
    
    - name: 创建Release说明
      run: |
        FINAL_BUILD_NUMBER="${{ needs.get-build-info.outputs.final-build-number }}"
        PATCH_VERSION="${{ needs.get-build-info.outputs.patch-version }}"
        BUILD_NUMBER="${{ needs.get-build-info.outputs.build-number }}"
        RELEASE_DATE="${{ needs.get-build-info.outputs.release-date }}"
        ICONS_SHA256="${{ steps.verify-packages.outputs.icons-sha256 }}"
        SDE_SHA256="${{ steps.verify-packages.outputs.sde-sha256 }}"
        ICON_VERSION="${{ steps.generate-metadata.outputs.icon-version }}"
        TIMESTAMP="${{ steps.timestamp.outputs.value }}"
        
        echo "[+] Icon Version: ${ICON_VERSION}"
        echo "[+] Timestamp: ${TIMESTAMP}"
        
        # 创建简短的Release说明
        RELEASE_NOTES_FILE="release_notes_${FINAL_BUILD_NUMBER}.md"
        
        echo "# EVE SDE Build ${FINAL_BUILD_NUMBER}" > "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo "## 构建信息" >> "$RELEASE_NOTES_FILE"
        echo "- **Build Number**: ${BUILD_NUMBER}" >> "$RELEASE_NOTES_FILE"
        if [ "$PATCH_VERSION" != "0" ]; then
          echo "- **Patch Version**: ${PATCH_VERSION}" >> "$RELEASE_NOTES_FILE"
        fi
        echo "- **Icon Version**: ${ICON_VERSION}" >> "$RELEASE_NOTES_FILE"
        echo "- **Release Date**: ${RELEASE_DATE}" >> "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo "## 版本元数据" >> "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo '```json' >> "$RELEASE_NOTES_FILE"
        cat metadata.json >> "$RELEASE_NOTES_FILE"
        echo '```' >> "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo "## 详细比较报告" >> "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo "详细的版本比较报告已保存到仓库：" >> "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo "[查看比较报告](https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/main/history/release_compare_${FINAL_BUILD_NUMBER}_${TIMESTAMP}.md)" >> "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo "## 下载文件" >> "$RELEASE_NOTES_FILE"
        echo "- **icons.zip**: 图标压缩包" >> "$RELEASE_NOTES_FILE"
        echo "- **sde.zip**: SDE数据压缩包" >> "$RELEASE_NOTES_FILE"
        echo "- **metadata.json**: 版本元数据文件（包含icon_version、哈希等信息）" >> "$RELEASE_NOTES_FILE"
        
        echo "[+] Release说明已生成: $RELEASE_NOTES_FILE"
    
    - name: 创建Release
      uses: softprops/action-gh-release@v2
      with:
        files: |
          icons.zip
          sde.zip
          metadata.json
        tag_name: sde-build-${{ needs.get-build-info.outputs.final-build-number }}
        name: EVE SDE Build ${{ needs.get-build-info.outputs.final-build-number }}
        body_path: release_notes_${{ needs.get-build-info.outputs.final-build-number }}.md
        draft: false
        prerelease: false
        fail_on_unmatched_files: false
        generate_release_notes: false
      env:
        GITHUB_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
    
    - name: 保存比对文件位置和带时间戳的文件名
      id: save-compare-file
      run: |
        FINAL_BUILD_NUMBER="${{ needs.get-build-info.outputs.final-build-number }}"
        TIMESTAMP="${{ steps.timestamp.outputs.value }}"
        COMPARE_FILE="release_compare_${FINAL_BUILD_NUMBER}.md"
        
        # 检查比对文件是否存在
        if [ -f "$COMPARE_FILE" ]; then
          # 生成带时间戳的新文件名
          NEW_COMPARE_FILE="release_compare_${FINAL_BUILD_NUMBER}_${TIMESTAMP}.md"
          
          # 保存绝对路径
          COMPARE_FILE_PATH=$(realpath "$COMPARE_FILE")
          echo "path=${COMPARE_FILE_PATH}" >> $GITHUB_OUTPUT
          echo "new-filename=${NEW_COMPARE_FILE}" >> $GITHUB_OUTPUT
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "[+] 比对文件存在: $COMPARE_FILE_PATH"
          echo "[+] 新文件名: $NEW_COMPARE_FILE"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "[!] 比对文件不存在"
        fi
    
    - name: 检出代码用于提交历史记录和物品详情
      if: (steps.save-compare-file.outputs.exists == 'true' || steps.build-sde.outputs.item-detail-extracted == 'true') && needs.get-build-info.outputs.debug-mode != 'true'
      uses: actions/checkout@v4
      with:
        ref: main
        path: repo
        token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
    
    - name: 提交比对记录和物品详情到仓库
      if: steps.save-compare-file.outputs.exists == 'true' && needs.get-build-info.outputs.debug-mode != 'true'
      run: |
        FINAL_BUILD_NUMBER="${{ needs.get-build-info.outputs.final-build-number }}"
        NEW_COMPARE_FILE="${{ steps.save-compare-file.outputs.new-filename }}"
        COMPARE_FILE_PATH="${{ steps.save-compare-file.outputs.path }}"
        
        echo "[+] 准备将比对记录和物品详情推送到仓库..."
        
        cd repo
        
        # 配置git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # 提交比对记录
        if [ "${{ steps.save-compare-file.outputs.exists }}" = "true" ]; then
          echo "[+] 处理比对记录: $NEW_COMPARE_FILE"
          
          # 创建history目录（如果不存在）
          mkdir -p history
          
          # 复制比对文件到history目录（使用带时间戳的新文件名）
          cp "$COMPARE_FILE_PATH" "history/$NEW_COMPARE_FILE"
          
          # 添加文件到git
          git add "history/$NEW_COMPARE_FILE"
        fi
        
        # 提交物品详情目录
        echo "[+] 检查物品详情提取状态: '${{ steps.build-sde.outputs.item-detail-extracted }}'"
        echo "[+] 比对文件存在状态: '${{ steps.save-compare-file.outputs.exists }}'"
        echo "[+] 当前目录内容:"
        ls -la
        
        # 总是尝试处理物品详情目录（不依赖outputs状态）
        echo "[+] 尝试处理物品详情目录"
        echo "[+] 检查artifact目录中的物品详情..."
        
        # 复制物品详情目录到repo目录（从artifact下载的目录复制）
        if [ -d "../item_detail_en" ]; then
          echo "[+] 复制英文版物品详情目录到repo"
          echo "[+] 英文版目录大小:"
          du -sh ../item_detail_en/
          cp -r "../item_detail_en" .
          git add "item_detail_en/"
          echo "[+] 英文版物品详情目录已添加到git"
        else
          echo "[!] 英文版物品详情目录不存在于artifact中"
        fi
        
        if [ -d "../item_detail_zh" ]; then
          echo "[+] 复制中文版物品详情目录到repo"
          echo "[+] 中文版目录大小:"
          du -sh ../item_detail_zh/
          cp -r "../item_detail_zh" .
          git add "item_detail_zh/"
          echo "[+] 中文版物品详情目录已添加到git"
        else
          echo "[!] 中文版物品详情目录不存在于artifact中"
        fi
        
        # 检查是否有变更
        if git diff --staged --quiet; then
          echo "[+] 没有新的变更需要提交"
        else
          # 构建提交信息
          COMMIT_MSG="Update SDE data for build ${FINAL_BUILD_NUMBER} [skip ci]"
          
          if [ "${{ steps.save-compare-file.outputs.exists }}" = "true" ]; then
            COMMIT_MSG="${COMMIT_MSG}\n- Add release compare: history/$NEW_COMPARE_FILE"
          fi
          
          if [ "${{ steps.build-sde.outputs.item-detail-extracted }}" = "true" ]; then
            COMMIT_MSG="${COMMIT_MSG}\n- Update item detail directories (en/zh)"
          fi
          
          # 提交变更
          git commit -m "$COMMIT_MSG"
          
          # 推送到远程仓库
          git push origin main
          
          echo "[+] 数据已推送到仓库"
          if [ "${{ steps.save-compare-file.outputs.exists }}" = "true" ]; then
            echo "[+] 比对记录: history/$NEW_COMPARE_FILE"
          fi
          if [ "${{ steps.build-sde.outputs.item-detail-extracted }}" = "true" ]; then
            echo "[+] 物品详情目录: item_detail_en/, item_detail_zh/"
          fi
        fi

  notify-completion:
    name: 通知完成
    runs-on: ubuntu-latest
    needs: [get-build-info, build-sde]
    if: always() && needs.get-build-info.outputs.new-build == 'true'
    
    steps:
    - name: 构建状态通知
      run: |
        FINAL_BUILD_NUMBER="${{ needs.get-build-info.outputs.final-build-number }}"
        PATCH_VERSION="${{ needs.get-build-info.outputs.patch-version }}"
        DEBUG_MODE="${{ needs.get-build-info.outputs.debug-mode }}"
        
        if [ "${{ needs.build-sde.result }}" == "success" ]; then
          if [ "$DEBUG_MODE" == "true" ]; then
            echo "[+] 调试模式：SDE构建成功完成（未创建Release）"
            echo "Final Build Number: $FINAL_BUILD_NUMBER"
          else
            echo "[+] SDE构建成功完成"
            echo "Final Build Number: $FINAL_BUILD_NUMBER"
            if [ "$PATCH_VERSION" != "0" ]; then
              echo "Patch Version: $PATCH_VERSION"
            fi
            echo "[+] 注意：Release创建状态请查看 create-release job"
          fi
        else
          echo "[x] SDE构建失败"
          echo "Final Build Number: $FINAL_BUILD_NUMBER"
          echo "请检查GitHub Actions日志"
        fi
