name: Auto SDE Build and Release

on:
  workflow_dispatch:
    inputs:
      build_patch:
        description: '构建补丁包（即使已存在相同buildNumber的release也重新构建）'
        required: false
        default: false
        type: boolean
  schedule:
    # 每天固定时间（UTC时间）
    - cron: '0 0 * * *'    # 北京时间 08:00
    - cron: '0 4 * * *'    # 北京时间 12:00
    - cron: '0 11 * * *'   # 北京时间 19:00
    - cron: '30 11 * * *'  # 北京时间 19:30
    - cron: '0 14 * * *'   # 北京时间 22:00

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

jobs:
  get-build-info:
    name: 获取SDE版本信息
    runs-on: ubuntu-latest
    
    outputs:
      build-number: ${{ steps.get-build-info.outputs.build-number }}
      release-date: ${{ steps.get-build-info.outputs.release-date }}
      build-key: ${{ steps.get-build-info.outputs.build-key }}
      new-build: ${{ steps.get-build-info.outputs.new-build }}
      patch-version: ${{ steps.get-build-info.outputs.patch-version }}
      final-build-number: ${{ steps.get-build-info.outputs.final-build-number }}
    
    steps:
    - name: 获取SDE版本信息并检查重复
      id: get-build-info
      run: |
        echo "[+] 获取最新SDE版本信息..."
        
        # 获取最新SDE信息
        SDE_INFO=$(curl -s "https://developers.eveonline.com/static-data/tranquility/latest.jsonl" | jq -r '.')
        
        BUILD_NUMBER=$(echo "$SDE_INFO" | jq -r '.buildNumber')
        RELEASE_DATE=$(echo "$SDE_INFO" | jq -r '.releaseDate')
        BUILD_KEY=$(echo "$SDE_INFO" | jq -r '._key')
        
        echo "Build number: ${BUILD_NUMBER}"
        echo "Release date: ${RELEASE_DATE}"
        echo "Build key: ${BUILD_KEY}"
        
        # 检查是否为补丁包构建
        BUILD_PATCH="${{ github.event.inputs.build_patch }}"
        echo "Build patch mode: ${BUILD_PATCH}"
        
        # 首先检查原始buildNumber的release是否已存在
        TAG_NAME="sde-build-${BUILD_NUMBER}"
        echo "[+] 检查Release是否已存在: ${TAG_NAME}"
        
        RELEASE_EXISTS=$(curl -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -s \
          "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG_NAME}" | jq -r '.id')
        
        if [ "$BUILD_PATCH" = "true" ]; then
          echo "[+] 补丁包模式：强制重新构建"
          
          if [ "$RELEASE_EXISTS" != "null" ] && [ -n "$RELEASE_EXISTS" ]; then
            echo "[+] 原始版本已存在，查找下一个可用的补丁版本号"
            
            # 查找已存在的补丁版本
            PATCH_VERSION=1
            FINAL_BUILD_NUMBER="${BUILD_NUMBER}.01"
            
            # 检查补丁版本直到找到可用的版本号（最多99次）
            while [ $PATCH_VERSION -le 99 ]; do
              PATCH_STR=$(printf "%02d" $PATCH_VERSION)
              TAG_NAME="sde-build-${BUILD_NUMBER}.${PATCH_STR}"
              
              echo "[+] 检查补丁版本: ${TAG_NAME}"
              RELEASE_EXISTS=$(curl -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -s \
                "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG_NAME}" | jq -r '.id')
              
              if [ "$RELEASE_EXISTS" = "null" ] || [ -z "$RELEASE_EXISTS" ]; then
                echo "[+] 找到可用的补丁版本: ${TAG_NAME}"
                FINAL_BUILD_NUMBER="${BUILD_NUMBER}.${PATCH_STR}"
                NEW_BUILD="true"
                break
              else
                echo "补丁版本 ${TAG_NAME} 已存在，尝试下一个"
                PATCH_VERSION=$((PATCH_VERSION + 1))
              fi
            done
            
            if [ $PATCH_VERSION -gt 99 ]; then
              echo "[x] 错误：已达到补丁版本上限（99），无法创建新的补丁包"
              exit 1
            fi
          else
            echo "[+] 原始版本不存在，直接使用原始buildNumber"
            FINAL_BUILD_NUMBER="${BUILD_NUMBER}"
            PATCH_VERSION=0
            NEW_BUILD="true"
          fi
          
          echo "patch-version=${PATCH_VERSION}" >> $GITHUB_OUTPUT
          echo "final-build-number=${FINAL_BUILD_NUMBER}" >> $GITHUB_OUTPUT
        else
          # 正常模式：检查Release是否已存在
          if [ "$RELEASE_EXISTS" != "null" ] && [ -n "$RELEASE_EXISTS" ]; then
            echo "Release ${TAG_NAME} 已存在，跳过构建"
            NEW_BUILD="false"
          else
            echo "新版本 ${TAG_NAME} 需要构建"
            NEW_BUILD="true"
          fi
          
          echo "patch-version=0" >> $GITHUB_OUTPUT
          echo "final-build-number=${BUILD_NUMBER}" >> $GITHUB_OUTPUT
        fi
        
        echo "build-number=${BUILD_NUMBER}" >> $GITHUB_OUTPUT
        echo "release-date=${RELEASE_DATE}" >> $GITHUB_OUTPUT
        echo "build-key=${BUILD_KEY}" >> $GITHUB_OUTPUT
        echo "new-build=${NEW_BUILD}" >> $GITHUB_OUTPUT

  build-sde:
    name: 构建SDE数据库
    runs-on: ubuntu-latest
    
    needs: [get-build-info]
    if: needs.get-build-info.outputs.new-build == 'true'
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
    
    - name: 设置Python环境
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: 安装依赖
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: 执行SDE构建
      run: |
        echo "[+] 执行SDE构建"
        echo "[+] Build Number: ${{ needs.get-build-info.outputs.build-number }}"
        echo "[+] Final Build Number: ${{ needs.get-build-info.outputs.final-build-number }}"
        echo "[+] Patch Version: ${{ needs.get-build-info.outputs.patch-version }}"
        
        # 设置环境变量，让main.py知道最终的build number
        export FINAL_BUILD_NUMBER="${{ needs.get-build-info.outputs.final-build-number }}"
        export PATCH_VERSION="${{ needs.get-build-info.outputs.patch-version }}"
        
        python -u main.py
        
    - name: 上传构建产物
      uses: actions/upload-artifact@v4
      with:
        name: sde-output-${{ needs.get-build-info.outputs.final-build-number }}
        path: |
          output_sde/
          output_icons/
          release_compare_${{ needs.get-build-info.outputs.final-build-number }}.md
        retention-days: 30

  create-release:
    name: 创建Release
    runs-on: ubuntu-latest
    
    needs: [get-build-info, build-sde]
    if: needs.get-build-info.outputs.new-build == 'true'
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
    
    - name: 下载构建产物
      uses: actions/download-artifact@v4
      with:
        name: sde-output-${{ needs.get-build-info.outputs.final-build-number }}
        path: ./
    
    - name: 处理图标版本号
      id: process-icon-version
      run: |
        FINAL_BUILD_NUMBER="${{ needs.get-build-info.outputs.final-build-number }}"
        
        echo "[+] 开始处理图标版本号..."
        
        # 计算当前图标包的SHA256
        if [ -f "output_icons/icons.zip" ]; then
          CURRENT_ICON_SHA256=$(sha256sum "output_icons/icons.zip" | cut -d' ' -f1)
          echo "[+] 当前图标包SHA256: $CURRENT_ICON_SHA256"
        else
          echo "[x] 图标压缩包不存在: output_icons/icons.zip"
          exit 1
        fi
        
        # 获取最新release信息并下载旧版本SDE
        echo "[+] 获取最新release信息..."
        LATEST_RELEASE=$(curl -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -s \
          "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/latest" || echo "")
        
        # 检查API调用是否成功
        if [ -z "$LATEST_RELEASE" ]; then
          echo "[!] 无法获取release信息，可能是网络问题或首次构建"
        fi
        
        # 检查是否有历史release
        if [ "$(echo "$LATEST_RELEASE" | jq -r '.message // empty')" = "Not Found" ] || [ -z "$LATEST_RELEASE" ]; then
          echo "[+] 首次构建（无历史release），图标版本号设为1"
          ICON_VERSION=1
        else
          echo "[+] 下载旧版本SDE以获取图标版本号..."
          
          # 下载旧版本的sde.zip
          SDE_DOWNLOAD_URL=$(echo "$LATEST_RELEASE" | jq -r '.assets[] | select(.name=="sde.zip") | .browser_download_url')
          if [ -n "$SDE_DOWNLOAD_URL" ] && [ "$SDE_DOWNLOAD_URL" != "null" ]; then
            # 创建临时目录
            TEMP_DIR=$(mktemp -d)
            OLD_SDE_ZIP="$TEMP_DIR/sde.zip"
            OLD_SDE_DIR="$TEMP_DIR/sde_old"
            
            # 下载旧版本SDE
            curl -L -o "$OLD_SDE_ZIP" "$SDE_DOWNLOAD_URL"
            
            # 解压旧版本SDE
            mkdir -p "$OLD_SDE_DIR"
            unzip -q "$OLD_SDE_ZIP" -d "$OLD_SDE_DIR"
            
            # 从旧版本sqlite数据库中读取图标版本号
            OLD_ICON_VERSION=1  # 默认值
            HAS_ICON_VERSION_COLUMN=false
            for lang in en zh; do
              OLD_DB_PATH="$OLD_SDE_DIR/db/item_db_${lang}.sqlite"
              if [ -f "$OLD_DB_PATH" ]; then
                # 检查是否有icon_version列
                HAS_ICON_VERSION=$(sqlite3 "$OLD_DB_PATH" "PRAGMA table_info(version_info);" | grep -c "icon_version" 2>/dev/null || echo "0")
                # 去除可能的换行符
                HAS_ICON_VERSION=$(echo "$HAS_ICON_VERSION" | tr -d '\n\r')
                if [ "$HAS_ICON_VERSION" -gt 0 ]; then
                  # 读取图标版本号
                  OLD_ICON_VERSION=$(sqlite3 "$OLD_DB_PATH" "SELECT icon_version FROM version_info LIMIT 1;" 2>/dev/null || echo "1")
                  # 去除可能的换行符
                  OLD_ICON_VERSION=$(echo "$OLD_ICON_VERSION" | tr -d '\n\r')
                  echo "[+] 从旧版本数据库读取图标版本号: $OLD_ICON_VERSION"
                  HAS_ICON_VERSION_COLUMN=true
                  break
                fi
              fi
            done
            
            if [ "$HAS_ICON_VERSION_COLUMN" = false ]; then
              echo "[+] 旧版本数据库没有icon_version列，默认为1"
              OLD_ICON_VERSION=1
            fi
            
            # 清理临时文件
            rm -rf "$TEMP_DIR"
            
            # 比较图标包SHA256（这里我们需要获取旧版本的图标包SHA256）
            # 从assets的digest字段获取旧版本图标包SHA256
            OLD_ICON_SHA256=$(echo "$LATEST_RELEASE" | jq -r '.assets[] | select(.name=="icons.zip") | .digest' | sed 's/sha256://')
            
            if [ -z "$OLD_ICON_SHA256" ] || [ "$OLD_ICON_SHA256" = "null" ]; then
              echo "[+] 未找到历史图标包SHA256，图标版本号递增"
              ICON_VERSION=$((OLD_ICON_VERSION + 1))
            else
              echo "[+] 最新release图标包SHA256: $OLD_ICON_SHA256"
              
              # 比较SHA256
              if [ "$CURRENT_ICON_SHA256" = "$OLD_ICON_SHA256" ]; then
                echo "[+] 图标包未变化，保持当前版本号"
                ICON_VERSION=$OLD_ICON_VERSION
              else
                echo "[+] 图标包已变化，版本号递增"
                ICON_VERSION=$((OLD_ICON_VERSION + 1))
              fi
            fi
            
            # 特殊处理：如果旧版本没有icon_version列，且图标哈希相同，则保持版本号1
            if [ "$HAS_ICON_VERSION_COLUMN" = false ] && [ "$CURRENT_ICON_SHA256" = "$OLD_ICON_SHA256" ]; then
              echo "[+] 旧版本没有icon_version列且图标哈希相同，保持版本号1"
              ICON_VERSION=1
            fi
          else
            echo "[+] 未找到旧版本SDE，图标版本号设为1"
            ICON_VERSION=1
          fi
        fi
        
        echo "[+] 图标版本号: $ICON_VERSION"
        echo "icon_version=$ICON_VERSION" >> $GITHUB_OUTPUT
        echo "icon_sha256=$CURRENT_ICON_SHA256" >> $GITHUB_OUTPUT

    - name: 更新数据库中的图标版本号
      run: |
        FINAL_BUILD_NUMBER="${{ needs.get-build-info.outputs.final-build-number }}"
        ICON_VERSION="${{ steps.process-icon-version.outputs.icon_version }}"
        
        echo "[+] 更新数据库中的图标版本号: $ICON_VERSION"
        
        # 运行Python脚本更新数据库
        python3 -c "
        import sqlite3
        import os
        from pathlib import Path
        
        # 获取配置
        project_root = Path('.')
        db_output_path = project_root / 'output_sde' / 'db'
        languages = ['en', 'zh']  # 根据实际配置调整
        
        icon_version = int('$ICON_VERSION')
        
        print(f'[+] 更新图标版本号: {icon_version}')
        
        for lang in languages:
            db_path = db_output_path / f'item_db_{lang}.sqlite'
            if db_path.exists():
                try:
                    conn = sqlite3.connect(str(db_path))
                    cursor = conn.cursor()
                    
                    # 检查version_info表是否存在icon_version列
                    cursor.execute('PRAGMA table_info(version_info)')
                    columns = [column[1] for column in cursor.fetchall()]
                    
                    if 'icon_version' not in columns:
                        # 添加icon_version列
                        cursor.execute('ALTER TABLE version_info ADD COLUMN icon_version INTEGER DEFAULT 1')
                        print(f'[+] 添加icon_version列到 {db_path.name}')
                    
                    # 检查是否有version_info记录
                    cursor.execute('SELECT COUNT(*) FROM version_info')
                    count = cursor.fetchone()[0]
                    
                    if count == 0:
                        # 如果没有记录，插入新记录（首次构建的情况）
                        cursor.execute('''
                            INSERT INTO version_info (build_number, patch_number, icon_version, release_date, build_key, description)
                            VALUES (?, ?, ?, ?, ?, ?)
                        ''', (0, 0, icon_version, '', '', 'EVE SDE Database Version Information'))
                        print(f'[+] 插入新记录到 {db_path.name} (首次构建)')
                    else:
                        # 更新现有记录的icon_version
                        cursor.execute('UPDATE version_info SET icon_version = ?', (icon_version,))
                        print(f'[+] 更新现有记录到 {db_path.name}')
                    
                    conn.commit()
                    conn.close()
                    
                    print(f'[+] 更新完成: {db_path.name}')
                except Exception as e:
                    print(f'[x] 更新失败: {db_path.name} - {e}')
                    import traceback
                    traceback.print_exc()
            else:
                print(f'[!] 数据库文件不存在: {db_path}')
        
        print('[+] 图标版本号更新完成')
        "

    - name: 验证图标版本号写入
      run: |
        ICON_VERSION="${{ steps.process-icon-version.outputs.icon_version }}"
        
        echo "[+] 验证图标版本号是否已正确写入数据库..."
        
        # 验证数据库中的图标版本号
        for lang in en zh; do
          DB_PATH="output_sde/db/item_db_${lang}.sqlite"
          if [ -f "$DB_PATH" ]; then
            # 检查是否有icon_version列
            HAS_ICON_VERSION=$(sqlite3 "$DB_PATH" "PRAGMA table_info(version_info);" | grep -c "icon_version" 2>/dev/null || echo "0")
            # 去除可能的换行符
            HAS_ICON_VERSION=$(echo "$HAS_ICON_VERSION" | tr -d '\n\r')
            if [ "$HAS_ICON_VERSION" -gt 0 ]; then
              # 读取图标版本号
              DB_ICON_VERSION=$(sqlite3 "$DB_PATH" "SELECT icon_version FROM version_info LIMIT 1;" 2>/dev/null || echo "0")
              # 去除可能的换行符
              DB_ICON_VERSION=$(echo "$DB_ICON_VERSION" | tr -d '\n\r')
              if [ "$DB_ICON_VERSION" = "$ICON_VERSION" ]; then
                echo "[+] 验证通过: ${lang} 数据库图标版本号 = $DB_ICON_VERSION"
              else
                echo "[x] 验证失败: ${lang} 数据库图标版本号 = $DB_ICON_VERSION，期望 = $ICON_VERSION"
                exit 1
              fi
            else
              echo "[x] 验证失败: ${lang} 数据库没有icon_version列"
              exit 1
            fi
          else
            echo "[!] 数据库文件不存在: $DB_PATH"
          fi
        done
        
        echo "[+] 图标版本号验证完成"

    - name: 创建压缩包
      run: |
        FINAL_BUILD_NUMBER="${{ needs.get-build-info.outputs.final-build-number }}"
        ICON_VERSION="${{ steps.process-icon-version.outputs.icon_version }}"
        ICON_SHA256="${{ steps.process-icon-version.outputs.icon_sha256 }}"
        
        # 创建图标压缩包（从output_icons/icons.zip复制）
        if [ -f "output_icons/icons.zip" ]; then
          cp "output_icons/icons.zip" "icons.zip"
          echo "[+] 图标压缩包创建完成: icons.zip"
        else
          echo "[x] 图标压缩包不存在: output_icons/icons.zip"
          exit 1
        fi
        
        # 创建SDE数据压缩包（直接压缩output_sde目录为ZIP格式）
        cd output_sde
        zip -r "../sde.zip" .
        cd ..
        
        echo "[+] SDE数据压缩包创建完成: sde.zip"
        echo "[+] 图标版本号: $ICON_VERSION"
        echo "[+] 图标SHA256: $ICON_SHA256"
        ls -la icons.zip sde.zip release_compare_${FINAL_BUILD_NUMBER}.md 2>/dev/null || ls -la icons.zip sde.zip
    
    - name: 验证压缩包
      id: verify-packages
      run: |
        echo "[+] 验证压缩包..."
        
        # 验证图标压缩包
        if [ ! -f "icons.zip" ]; then
          echo "[x] 图标压缩包不存在: icons.zip"
          exit 1
        fi
        
        ICONS_SIZE=$(stat -c%s "icons.zip")
        ICONS_SIZE_MB=$((ICONS_SIZE / 1024 / 1024))
        echo "[+] 图标压缩包大小: ${ICONS_SIZE_MB} MB (${ICONS_SIZE} bytes)"
        
        # 验证SDE数据压缩包
        if [ ! -f "sde.zip" ]; then
          echo "[x] SDE数据压缩包不存在: sde.zip"
          exit 1
        fi
        
        SDE_SIZE=$(stat -c%s "sde.zip")
        SDE_SIZE_MB=$((SDE_SIZE / 1024 / 1024))
        echo "[+] SDE数据压缩包大小: ${SDE_SIZE_MB} MB (${SDE_SIZE} bytes)"
        
        # 检查压缩包大小是否合理
        if [ $ICONS_SIZE_MB -lt 1 ]; then
          echo "[x] 图标压缩包大小异常，可能构建失败"
          exit 1
        fi
        
        if [ $SDE_SIZE_MB -lt 5 ]; then
          echo "[x] SDE数据压缩包大小异常，可能构建失败"
          exit 1
        fi
        
        # 计算压缩包哈希值
        ICONS_SHA256=$(sha256sum "icons.zip" | cut -d' ' -f1)
        SDE_SHA256=$(sha256sum "sde.zip" | cut -d' ' -f1)
        echo "[+] 图标压缩包SHA256: $ICONS_SHA256"
        echo "[+] SDE数据压缩包SHA256: $SDE_SHA256"
        
        # 将SHA256值输出到环境变量，供后续步骤使用
        echo "icons-sha256=${ICONS_SHA256}" >> $GITHUB_OUTPUT
        echo "sde-sha256=${SDE_SHA256}" >> $GITHUB_OUTPUT
        
        # 验证压缩包完整性
        if unzip -t "icons.zip" > /dev/null 2>&1; then
          echo "[+] 图标压缩包完整性验证通过"
        else
          echo "[x] 图标压缩包损坏或格式错误"
          exit 1
        fi
        
        if unzip -t "sde.zip" > /dev/null 2>&1; then
          echo "[+] SDE数据压缩包完整性验证通过"
        else
          echo "[x] SDE数据压缩包损坏或格式错误"
          exit 1
        fi
        
        # 显示压缩包内容概览
        echo "[+] 图标压缩包内容概览:"
        unzip -l "icons.zip" | head -10
        
        echo "[+] SDE数据压缩包内容概览:"
        unzip -l "sde.zip" | head -10
        SDE_TOTAL_FILES=$(unzip -l "sde.zip" | tail -1 | awk '{print $2}')
        echo "[+] SDE数据压缩包包含 $SDE_TOTAL_FILES 个文件"
        
        # 显示sde.zip的目录结构（tree视图）
        echo "[+] SDE数据压缩包目录结构:"
        echo "sde.zip"
        unzip -l "sde.zip" | grep -E '\.(sqlite|json|log)$' | awk '{print "├── " $4}' | sort | head -20
        if [ $(unzip -l "sde.zip" | grep -E '\.(sqlite|json|log)$' | wc -l) -gt 20 ]; then
          echo "└── ... (还有更多文件)"
        fi
        
        echo "[+] 压缩包验证完成"
    
    
    - name: 创建Release说明
      run: |
        FINAL_BUILD_NUMBER="${{ needs.get-build-info.outputs.final-build-number }}"
        PATCH_VERSION="${{ needs.get-build-info.outputs.patch-version }}"
        BUILD_NUMBER="${{ needs.get-build-info.outputs.build-number }}"
        RELEASE_DATE="${{ needs.get-build-info.outputs.release-date }}"
        ICON_VERSION="${{ steps.process-icon-version.outputs.icon_version }}"
        ICON_SHA256="${{ steps.process-icon-version.outputs.icon_sha256 }}"
        ICONS_SHA256="${{ steps.verify-packages.outputs.icons-sha256 }}"
        SDE_SHA256="${{ steps.verify-packages.outputs.sde-sha256 }}"
        
        # 创建简短的Release说明
        RELEASE_NOTES_FILE="release_notes_${FINAL_BUILD_NUMBER}.md"
        
        echo "# EVE SDE Build ${FINAL_BUILD_NUMBER}" > "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo "## 构建信息" >> "$RELEASE_NOTES_FILE"
        echo "- **Build Number**: ${BUILD_NUMBER}" >> "$RELEASE_NOTES_FILE"
        if [ "$PATCH_VERSION" != "0" ]; then
          echo "- **Patch Version**: ${PATCH_VERSION}" >> "$RELEASE_NOTES_FILE"
        fi
        echo "- **icon_version**: ${ICON_VERSION}" >> "$RELEASE_NOTES_FILE"
        echo "- **icon_sha256**: ${ICON_SHA256}" >> "$RELEASE_NOTES_FILE"
        echo "- **sde_sha256**: ${SDE_SHA256}" >> "$RELEASE_NOTES_FILE"
        echo "- **Release Date**: ${RELEASE_DATE}" >> "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo "## 详细比较报告" >> "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo "请查看详细的版本比较报告：" >> "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo "[下载详细比较报告](https://github.com/${GITHUB_REPOSITORY}/releases/download/sde-build-${FINAL_BUILD_NUMBER}/release_compare_${FINAL_BUILD_NUMBER}.md)" >> "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo "或者下载附件中的 \`release_compare_${FINAL_BUILD_NUMBER}.md\` 文件。" >> "$RELEASE_NOTES_FILE"
        echo "" >> "$RELEASE_NOTES_FILE"
        echo "## 下载文件" >> "$RELEASE_NOTES_FILE"
        echo "- **icons.zip**: 图标压缩包" >> "$RELEASE_NOTES_FILE"
        echo "- **sde.zip**: SDE数据压缩包" >> "$RELEASE_NOTES_FILE"
        echo "- **release_compare_${FINAL_BUILD_NUMBER}.md**: 详细比较报告" >> "$RELEASE_NOTES_FILE"
        
        echo "[+] Release说明已生成: $RELEASE_NOTES_FILE"
    
    - name: 创建Release
      uses: softprops/action-gh-release@v2
      with:
        files: |
          icons.zip
          sde.zip
          release_compare_${{ needs.get-build-info.outputs.final-build-number }}.md
        tag_name: sde-build-${{ needs.get-build-info.outputs.final-build-number }}
        name: EVE SDE Build ${{ needs.get-build-info.outputs.final-build-number }}
        body_path: release_notes_${{ needs.get-build-info.outputs.final-build-number }}.md
        draft: false
        prerelease: false
        fail_on_unmatched_files: false
        generate_release_notes: false
      env:
        GITHUB_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}

  notify-completion:
    name: 通知完成
    runs-on: ubuntu-latest
    needs: [get-build-info, build-sde, create-release]
    if: always() && needs.get-build-info.outputs.new-build == 'true'
    
    steps:
    - name: 构建状态通知
      run: |
        FINAL_BUILD_NUMBER="${{ needs.get-build-info.outputs.final-build-number }}"
        PATCH_VERSION="${{ needs.get-build-info.outputs.patch-version }}"
        
        if [ "${{ needs.build-sde.result }}" == "success" ] && [ "${{ needs.create-release.result }}" == "success" ]; then
          echo "[+] SDE构建成功完成"
          echo "Final Build Number: $FINAL_BUILD_NUMBER"
          if [ "$PATCH_VERSION" != "0" ]; then
            echo "Patch Version: $PATCH_VERSION"
          fi
          echo "Release: https://github.com/${GITHUB_REPOSITORY}/releases/tag/sde-build-$FINAL_BUILD_NUMBER"
        else
          echo "[x] SDE构建失败"
          echo "Final Build Number: $FINAL_BUILD_NUMBER"
          echo "请检查GitHub Actions日志"
        fi
